// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: payments.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestOverdue = `-- name: GetLatestOverdue :one
SELECT id, payment_id, is_overdue, days_overdue, penalty, penalty_currency, calculated_at, created_at
FROM payment_overdues
WHERE payment_id = $1
ORDER BY calculated_at DESC
LIMIT 1
`

func (q *Queries) GetLatestOverdue(ctx context.Context, paymentID string) (PaymentOverdue, error) {
	row := q.db.QueryRow(ctx, getLatestOverdue, paymentID)
	var i PaymentOverdue
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.IsOverdue,
		&i.DaysOverdue,
		&i.Penalty,
		&i.PenaltyCurrency,
		&i.CalculatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT id, user_id, amount, currency, due_date, paid_at, status, created_at, updated_at 
FROM payments 
WHERE id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id string) (Payment, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.Currency,
		&i.DueDate,
		&i.PaidAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertOverdue = `-- name: InsertOverdue :exec
INSERT INTO payment_overdues (id, payment_id, is_overdue, days_overdue, penalty, penalty_currency, calculated_at, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertOverdueParams struct {
	ID              string             `json:"id"`
	PaymentID       string             `json:"payment_id"`
	IsOverdue       bool               `json:"is_overdue"`
	DaysOverdue     int32              `json:"days_overdue"`
	Penalty         pgtype.Numeric     `json:"penalty"`
	PenaltyCurrency string             `json:"penalty_currency"`
	CalculatedAt    pgtype.Date        `json:"calculated_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) InsertOverdue(ctx context.Context, arg InsertOverdueParams) error {
	_, err := q.db.Exec(ctx, insertOverdue,
		arg.ID,
		arg.PaymentID,
		arg.IsOverdue,
		arg.DaysOverdue,
		arg.Penalty,
		arg.PenaltyCurrency,
		arg.CalculatedAt,
		arg.CreatedAt,
	)
	return err
}

const upsertPayment = `-- name: UpsertPayment :exec
INSERT INTO payments (id, user_id, amount, currency, due_date, paid_at, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (id) DO UPDATE SET 
    amount = EXCLUDED.amount,
    paid_at = EXCLUDED.paid_at,
    status = EXCLUDED.status,
    updated_at = EXCLUDED.updated_at
`

type UpsertPaymentParams struct {
	ID        string             `json:"id"`
	UserID    string             `json:"user_id"`
	Amount    pgtype.Numeric     `json:"amount"`
	Currency  string             `json:"currency"`
	DueDate   pgtype.Date        `json:"due_date"`
	PaidAt    pgtype.Timestamptz `json:"paid_at"`
	Status    string             `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpsertPayment(ctx context.Context, arg UpsertPaymentParams) error {
	_, err := q.db.Exec(ctx, upsertPayment,
		arg.ID,
		arg.UserID,
		arg.Amount,
		arg.Currency,
		arg.DueDate,
		arg.PaidAt,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
